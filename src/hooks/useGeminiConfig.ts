'use client';\n\nimport { useState, useEffect } from 'react';\nimport { enhancedBaileysAPI, GeminiConfigData, ProcessIAResponse } from '@/lib/enhanced-baileys-api';\nimport { useAuthStore } from '@/store/authStore';\n\ninterface UseGeminiConfig {\n  config: GeminiConfigData | null;\n  isLoading: boolean;\n  error: string | null;\n  saveConfig: (config: Omit<GeminiConfigData, 'id' | 'fechaCreacion' | 'ultimaActualizacion'>) => Promise<boolean>;\n  updateConfig: (configId: string, config: Partial<GeminiConfigData>) => Promise<boolean>;\n  deleteConfig: (configId: string) => Promise<boolean>;\n  testConfig: (config: GeminiConfigData, testMessage?: string) => Promise<ProcessIAResponse>;\n  processMessage: (body: string, number: string, configId?: string) => Promise<ProcessIAResponse>;\n  refresh: () => Promise<void>;\n}\n\n/**\n * Hook para manejar la configuración de Gemini IA\n */\nexport const useGeminiConfig = (): UseGeminiConfig => {\n  const [config, setConfig] = useState<GeminiConfigData | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { token } = useAuthStore();\n\n  // Cargar configuración al montar el componente\n  useEffect(() => {\n    if (token) {\n      loadConfig();\n    }\n  }, [token]);\n\n  const loadConfig = async () => {\n    if (!token) return;\n    \n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const response = await enhancedBaileysAPI.getGeminiConfig(token);\n      if (response.success) {\n        setConfig(response.data);\n      } else {\n        setError(response.message || 'Error al cargar configuración');\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error al cargar configuración');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const saveConfig = async (newConfig: Omit<GeminiConfigData, 'id' | 'fechaCreacion' | 'ultimaActualizacion'>): Promise<boolean> => {\n    if (!token) {\n      setError('Token de autenticación no disponible');\n      return false;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await enhancedBaileysAPI.saveGeminiConfig({\n        token,\n        config: newConfig\n      });\n\n      if (response.success) {\n        setConfig(response.data);\n        return true;\n      } else {\n        setError(response.message || 'Error al guardar configuración');\n        return false;\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error al guardar configuración');\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const updateConfig = async (configId: string, updates: Partial<GeminiConfigData>): Promise<boolean> => {\n    if (!token) {\n      setError('Token de autenticación no disponible');\n      return false;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await enhancedBaileysAPI.updateGeminiConfig({\n        token,\n        configId,\n        config: updates\n      });\n\n      if (response.success) {\n        setConfig(response.data);\n        return true;\n      } else {\n        setError(response.message || 'Error al actualizar configuración');\n        return false;\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error al actualizar configuración');\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const deleteConfig = async (configId: string): Promise<boolean> => {\n    if (!token) {\n      setError('Token de autenticación no disponible');\n      return false;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await enhancedBaileysAPI.deleteGeminiConfig({\n        token,\n        configId\n      });\n\n      if (response.success) {\n        setConfig(null);\n        return true;\n      } else {\n        setError(response.message || 'Error al eliminar configuración');\n        return false;\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error al eliminar configuración');\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const testConfig = async (testConfig: GeminiConfigData, testMessage?: string): Promise<ProcessIAResponse> => {\n    setError(null);\n    \n    try {\n      const response = await enhancedBaileysAPI.testGeminiConfig({\n        config: testConfig,\n        testMessage\n      });\n      \n      if (!response.success && response.error) {\n        setError(response.error);\n      }\n      \n      return response;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Error al probar configuración';\n      setError(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  };\n\n  const processMessage = async (body: string, number: string, configId?: string): Promise<ProcessIAResponse> => {\n    if (!token) {\n      const errorMessage = 'Token de autenticación no disponible';\n      setError(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n\n    setError(null);\n\n    try {\n      const response = await enhancedBaileysAPI.processWithIA({\n        token,\n        body,\n        number,\n        configId\n      });\n\n      if (!response.success && response.error) {\n        setError(response.error);\n      }\n\n      return response;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Error al procesar mensaje';\n      setError(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  };\n\n  const refresh = async () => {\n    await loadConfig();\n  };\n\n  return {\n    config,\n    isLoading,\n    error,\n    saveConfig,\n    updateConfig,\n    deleteConfig,\n    testConfig,\n    processMessage,\n    refresh\n  };\n};\n\n/**\n * Hook para usar directamente la API de IA sin autenticación\n */\nexport const useDirectIA = () => {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const processIADirect = async (data: {\n    body: string;\n    number: string;\n    config: GeminiConfigData;\n  }): Promise<ProcessIAResponse> => {\n    setIsProcessing(true);\n    setError(null);\n\n    try {\n      const response = await enhancedBaileysAPI.processIADirect({\n        body: data.body,\n        number: data.number,\n        userbot: data.config.userbot,\n        apikey: data.config.apikey,\n        server: data.config.server,\n        promt: data.config.promt,\n        pais: data.config.pais,\n        idioma: data.config.idioma,\n        numerodemensajes: data.config.numerodemensajes,\n        delay_seconds: data.config.delay_seconds,\n        temperature: data.config.temperature,\n        topP: data.config.topP,\n        maxOutputTokens: data.config.maxOutputTokens,\n        pause_timeout_minutes: data.config.pause_timeout_minutes,\n        ai_model: data.config.ai_model,\n        thinking_budget: data.config.thinking_budget\n      });\n\n      if (!response.success && response.error) {\n        setError(response.error);\n      }\n\n      return response;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Error al procesar con IA';\n      setError(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  return {\n    isProcessing,\n    error,\n    processIADirect\n  };\n};\n\nexport default useGeminiConfig;\n